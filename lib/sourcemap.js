// Generated by CoffeeScript 1.6.3
(function() {
  var LineMap, SourceMap, fs, path, vlq;

  fs = require('fs');

  path = require('path');

  vlq = require('./vlq');

  LineMap = (function() {
    function LineMap(line) {
      this.line = line;
      this.columns = [];
    }

    LineMap.prototype.add = function(column, sourceFile, _arg, options) {
      var sourceColumn, sourceLine;
      sourceLine = _arg[0], sourceColumn = _arg[1];
      if (options == null) {
        options = {};
      }
      if (this.columns[column] && options.noReplace) {
        return;
      }
      return this.columns[column] = {
        line: this.line,
        column: column,
        sourceLine: sourceLine,
        sourceColumn: sourceColumn,
        sourceFile: sourceFile
      };
    };

    LineMap.prototype.sourceLocation = function(column) {
      var mapping;
      while (!((mapping = this.columns[column]) || (column <= 0))) {
        column--;
      }
      return mapping && [mapping.sourceFile, mapping.sourceLine, mapping.sourceColumn];
    };

    return LineMap;

  })();

  SourceMap = (function() {
    var V3_SOURCEMAP_REGEX;

    function SourceMap(generatedFile) {
      this.generatedFile = generatedFile;
      this.lines = [];
    }

    SourceMap.prototype.add = function(sourceFile, sourceLocation, generatedLocation, options) {
      var column, line, lineMap, _base;
      if (options == null) {
        options = {};
      }
      line = generatedLocation[0], column = generatedLocation[1];
      lineMap = ((_base = this.lines)[line] || (_base[line] = new LineMap(line)));
      return lineMap.add(column, sourceFile, sourceLocation, options);
    };

    SourceMap.prototype.sourceLocation = function(_arg) {
      var column, line, lineMap;
      line = _arg[0], column = _arg[1];
      while (!((lineMap = this.lines[line]) || (line <= 0))) {
        line--;
      }
      return lineMap && lineMap.sourceLocation(column);
    };

    SourceMap.prototype.generate = function(options, code) {
      var buffer, lastColumn, lastSourceColumn, lastSourceIndex, lastSourceLine, lineMap, lineNumber, mapping, needComma, sourceIndex, sources, v3, writingline, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      if (code == null) {
        code = null;
      }
      writingline = 0;
      lastColumn = 0;
      lastSourceIndex = 0;
      lastSourceLine = 0;
      lastSourceColumn = 0;
      needComma = false;
      buffer = "";
      sources = [];
      _ref = this.lines;
      for (lineNumber = _i = 0, _len = _ref.length; _i < _len; lineNumber = ++_i) {
        lineMap = _ref[lineNumber];
        if (lineMap) {
          _ref1 = lineMap.columns;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            mapping = _ref1[_j];
            if (!(mapping)) {
              continue;
            }
            while (writingline < mapping.line) {
              lastColumn = 0;
              needComma = false;
              buffer += ";";
              writingline++;
            }
            if (needComma) {
              buffer += ",";
              needComma = false;
            }
            buffer += vlq.encode(mapping.column - lastColumn);
            lastColumn = mapping.column;
            sourceIndex = sources.indexOf(mapping.sourceFile);
            if (sourceIndex === -1) {
              sources.push(mapping.sourceFile);
              sourceIndex = sources.length - 1;
            }
            buffer += vlq.encode(sourceIndex - lastSourceIndex);
            lastSourceIndex = sourceIndex;
            buffer += vlq.encode(mapping.sourceLine - lastSourceLine);
            lastSourceLine = mapping.sourceLine;
            buffer += vlq.encode(mapping.sourceColumn - lastSourceColumn);
            lastSourceColumn = mapping.sourceColumn;
            needComma = true;
          }
        }
      }
      v3 = {
        version: 3,
        file: this.generatedFile,
        sourceRoot: options.sourceRoot || '',
        sources: sources,
        names: [],
        mappings: buffer
      };
      if (options.inline) {
        v3.sourcesContent = [code];
      }
      return JSON.stringify(v3, null, 2);
    };

    SourceMap.load = function(v3MapString, generatedFile) {
      var answer, generatedColumn, generatedLine, line, lines, name, nameIndex, segment, segments, sourceColumn, sourceFile, sourceIndex, sourceLine, v3, values, _i, _j, _len, _len1;
      answer = new SourceMap(generatedFile);
      v3 = JSON.parse(v3MapString);
      sourceIndex = 0;
      sourceLine = 0;
      sourceColumn = 0;
      nameIndex = 0;
      lines = v3.mappings.split(';');
      for (generatedLine = _i = 0, _len = lines.length; _i < _len; generatedLine = ++_i) {
        line = lines[generatedLine];
        if (line.length === 0) {
          continue;
        }
        generatedColumn = 0;
        sourceFile = v3.sources[sourceIndex] || '';
        name = v3.names[nameIndex] || '';
        segments = line.split(',');
        for (_j = 0, _len1 = segments.length; _j < _len1; _j++) {
          segment = segments[_j];
          values = vlq.decodeValues(segment);
          generatedColumn += values[0];
          if (values.length >= 4) {
            sourceIndex += values[1];
            sourceFile = v3.sources[sourceIndex] || '';
            sourceLine += values[2];
            sourceColumn += values[3];
          }
          if (values.length >= 5) {
            nameIndex += values[4];
            name = v3.names[nameIndex] || '';
          }
          answer.add(sourceFile, [sourceLine, sourceColumn], [generatedLine, generatedColumn]);
        }
      }
      return answer;
    };

    V3_SOURCEMAP_REGEX = /\n?\/\/#\s*sourceMappingURL\s*=\s*(\S*)\s*\n?/;

    SourceMap.loadForSourceFileSync = function(generatedFile) {
      var answer, mapFile, match, source, sourceDir, v3Map;
      answer = null;
      source = fs.readFileSync(generatedFile, "utf-8");
      match = V3_SOURCEMAP_REGEX.exec(source);
      if (match) {
        mapFile = match[1];
        sourceDir = path.dirname(generatedFile);
        mapFile = path.resolve(sourceDir, mapFile);
        v3Map = fs.readFileSync(mapFile, "utf-8");
        answer = this.load(v3Map);
      }
      return answer;
    };

    SourceMap.registerErrorHandler = function() {
      var getSourceMap, getSourceMapping, mungeStackFrame, prepareStackTrace, sourceMapCache, _ref;
      sourceMapCache = {};
      prepareStackTrace = (_ref = Error.prepareStackTrace) != null ? _ref : function(err, stack) {
        var buf, e, line, s, _i, _len, _ref1;
        buf = [];
        if (err.name || err.message) {
          buf.push("" + err.name + ": " + ((_ref1 = err.message) != null ? _ref1 : ''));
        }
        for (_i = 0, _len = stack.length; _i < _len; _i++) {
          s = stack[_i];
          try {
            line = "    at " + (s.toString());
          } catch (_error) {
            e = _error;
            try {
              line = "<error: " + e + ">";
            } catch (_error) {
              e = _error;
              line = "<error>";
            }
          }
          buf.push(line);
        }
        return buf.join("\n") + "\n";
      };
      getSourceMap = function(filename) {
        var err, sourceMap;
        if (filename in sourceMapCache) {
          sourceMap = sourceMapCache[filename];
        } else {
          try {
            sourceMap = SourceMap.loadForSourceFileSync(filename);
          } catch (_error) {
            err = _error;
            sourceMap = null;
          }
          sourceMapCache[filename] = sourceMap;
        }
        return sourceMap;
      };
      getSourceMapping = function(filename, line, column) {
        var sourceMap;
        sourceMap = getSourceMap(filename);
        if (sourceMap) {
          return sourceMap.sourceLocation([line - 1, column - 1]);
        }
      };
      mungeStackFrame = function(frame) {
        var column, fileName, line, source;
        if (frame.isNative()) {
          return;
        }
        fileName = frame.isEval() ? frame.getScriptNameOrSourceURL() : frame.getFileName();
        fileName || (fileName = "<anonymous>");
        line = frame.getLineNumber();
        column = frame.getColumnNumber();
        source = getSourceMapping(fileName, line, column);
        if (source) {
          fileName = source[0], line = source[1], column = source[2];
          line += 1;
          column += 1;
        }
        return Object.defineProperties(frame, {
          getFileName: {
            value: function() {
              return fileName;
            }
          },
          getLineNumber: {
            value: function() {
              return line;
            }
          },
          getColumnNumber: {
            value: function() {
              return column;
            }
          }
        });
      };
      return Error.prepareStackTrace = function(err, stack) {
        var frame, _i, _len;
        for (_i = 0, _len = stack.length; _i < _len; _i++) {
          frame = stack[_i];
          if (frame.getFunction() === exports.run) {
            break;
          }
          mungeStackFrame(frame);
        }
        return prepareStackTrace(err, stack);
      };
    };

    return SourceMap;

  })();

  module.exports = SourceMap;

}).call(this);
